import schedule
import time
import pandas as pd
import requests
from bs4 import BeautifulSoup
from fpdf import FPDF
from PIL import Image
import json
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import os

# Paramètres de l'email
receiver_emails = ["queenonzlsh@gmail.com", "iliashadaf11@gmail.com"]
smtp_server = 'smtp.gmail.com'
smtp_port = 587
sender_email = "hanae.ouazouneidrissi@gmail.com"
sender_password = "duda bhpx wprs seun"

def perform_scraping_and_saving():
    # Fonction d'extraction et d'envoi d'email
    df = pd.read_excel("Equipement_Annexe.xlsx")

    items_with_details = []

    for index, row in df.iterrows():
        description = row['Description']
        if pd.notna(description) and isinstance(description, str):  # Vérifie si description n'est pas NaN et est une chaîne
            print(f"Scraping description: {description}")
            scrap_result = scrap(description)
            
            if scrap_result:
                items_with_details.append(scrap_result)
    
    # Supprimer le fichier précédent s'il existe
    if os.path.exists("resultat.xlsx"):
        os.remove("resultat.xlsx")
    
    # Sauvegarder les résultats dans un fichier Excel
    df_resultats = pd.DataFrame(items_with_details, columns=['Description', 'CVE_ID', 'CVE_URL', 'Published_Date', 'Updated_Date', 'Source'])
    df_resultats.to_excel("resultat.xlsx", index=False)
    
    # Générer le PDF
    pdf_file_path = generate_pdf("resultat.xlsx", "items.json")
    
    # Envoyer l'email
    send_email(pdf_file_path)

def scrap(description):
    search_query = description.replace(' ', '+')
    url = f"https://www.cvedetails.com/vulnerability-list.php?cvss_score_min=&cvss_score_max=&cwe_id=&vendor_id=&product_id=&sort_by=&order_by=&search={search_query}"
    
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    
    # Exemple de données fictives
    cve_identifier = "CVE-2007-5168"  # Remplacer par les vrais résultats
    cve_url = "https://www.cvedetails.com/cve/CVE-2007-5168/?q=CVE-2007-5168"
    published_date = "N/A"
    updated_date = "N/A"
    source = "N/A"
    
    return [description, cve_identifier, cve_url, published_date, updated_date, source]

def load_items_from_json(json_file_path):
    with open(json_file_path, 'r') as json_file:
        items = json.load(json_file)
    return items

def generate_pdf(excel_file, json_file):
    pdf_file = "cve_report.pdf"
    df = pd.read_excel(excel_file)
    items = load_items_from_json(json_file)

    pdf = FPDF()
    pdf.add_page()
    
    # Ajout des deux logos en haut du PDF
    pdf.image("cve.png", 10, 8, 33)  # Position x=10, y=8, largeur=33
    pdf.image("hcplogo.png", 150, 8, 33)  # Position x=150, y=8, largeur=33

    pdf.set_font("Arial", size=12)
    
    pdf.ln(50)  # Ajoute un saut de ligne pour que le texte ne chevauche pas les logos

    max_width = 180
    max_height = 180
    
    for index, row in df.iterrows():
        description = row['Description']
        cve_id = row['CVE_ID']
        cve_url = row['CVE_URL']
        published_date = row['Published_Date']
        updated_date = row['Updated_Date']
        source = row['Source']
        
        line = f"Description: {description}, CVE_ID: {cve_id}, CVE_URL: {cve_url}, Published_Date: {published_date}, Updated_Date: {updated_date}, Source: {source}"
        pdf.cell(200, 10, txt=line, ln=True, align='L')

        # Ajouter l'image de l'équipement si disponible
        for item in items:
            if item.get('description') == description:
                image_path = item.get('image_path')
                if image_path and os.path.exists(image_path):
                    img = Image.open(image_path)
                    img_width, img_height = img.size
                    img_width, img_height = min(img_width, max_width), min(img_height, max_height)
                    
                    pdf.image(image_path, x=None, y=None, w=img_width, h=img_height)
    
    pdf.output(pdf_file)
    return pdf_file


def send_email(pdf_file_path):
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = ", ".join(receiver_emails)
    msg['Subject'] = 'CVE Report Sender'

    body = 'Please find the attached CVE report.'
    msg.attach(MIMEText(body, 'plain'))

    attachment = open(pdf_file_path, 'rb')
    part = MIMEBase('application', 'octet-stream')
    part.set_payload(attachment.read())
    encoders.encode_base64(part)
    part.add_header('Content-Disposition', f'attachment; filename={pdf_file_path}')
    msg.attach(part)
    attachment.close()

    try:
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(sender_email, sender_password)
        server.send_message(msg)
        print('Email sent successfully!')
    except Exception as e:
        print(f'Error: {e}')
    finally:
        server.quit()

    os.remove(pdf_file_path)

# Fonction pour exécuter immédiatement l'envoi d'un email
def send_first_email():
    print("Envoi du premier email...")
    perform_scraping_and_saving()

# Planifier l'envoi d'un email toutes les 5 heures
schedule.every(5).hours.do(perform_scraping_and_saving)

if __name__ == "__main__":
    # Envoyer un email dès que le programme est exécuté
    send_first_email()

    # Ensuite, planifier l'exécution toutes les 5 heures
    print("Planifié pour envoyer des emails toutes les 5 heures.")
    while True:
        schedule.run_pending()
        time.sleep(1)  # Vérifie toutes les secondes si une tâche doit être exécutée




def perform_scraping_and_saving():
    while True:
        # Vérifiez si le fichier de signalisation "stop_scraping.txt" existe
        if os.path.exists("stop_scraping.txt"):
            print("Scraping arrêté.")
            break

        # Code de scraping ici
        print("Scraping en cours...")

        # Simulez une pause (par exemple pour un scraping toutes les 10 secondes)
        time.sleep(10)

if __name__ == "__main__":
    perform_scraping_and_saving()
